// Стековые анаграммы
// Алгоритм:
// Встаём не первую букву результата. Пихаем в стек все буквы входного слова, пока не встретим
// букву, совпадающую с первой буквой результата.
// Далее у нас есть 2 альтернативы - вытолкнуть из стека текущую букву или попробовать 
// пихать в стек буквы дальше (пока не встретим следующую равную букву)
// Если выбрали вытолкнуть из стека букву - переходим к рассмотрению второй буквы результата.
// В конце определённой ветки алгоритма, когда мы запихнули все буквы в стек, 
// выполняется одно из условий:
// 1) Успех - Стек пуст и мы вытолкнули все буквы результата - возвращаем YES, 
// 2) Неуспех - либо стек не пуст, либо мы вытолкнули не все буквы результата - 
// 		возвращаем NO
// Если хотя бы одна подветка вернула YES, возвращаем YES. Если все вернули NO - возвращаем NO

// Время работы алгоритма в худшем случае O(n^2) (когда почти все буквы одинаковые):
// - на любой букве у нас задача может разделиться на 2 подзадачи 
// (продолжить поиск или вытолкнуть букву) размером T(n-1).

// Если все буквы разные - это лучший случай - время работы O(n^2).
// Пример для лучшего случая:
//  abcdefghijklmnopqrstuvwxyz
//  abcdefghijklmnopqrstuvwxyz
// На каждой букве мы делимся за всё время ровно один раз, в одной из веток 
// сканируя оставшуюся часть массива уже без делений.

// Дополнительная память во всех случаях - O(n^2) (передаем стек в каждую подзадачу)

#include <iostream>
#include <stack>
#include <string>

// out - то слово, которое должны получить
// in - входное слово
// it - итератор для входного слова (указатель на текущую позицию в слове)
// s - стек, который мы используем для конструирования нового слова
//
// Мы идём по буквам в in, запихиваем эти буквы в стек s.
// Из s мы выталкиваем буквы "в никуда", если очередная буква совпадает с нужной буквой в out.
bool IsStackAnagram(std::string &in, std::string &out, int it, std::stack<char> s) {
	int n = (int)in.size();
		
    // Заталкиваем в стек все оставшиеся элементы; 
	// Если очередной элемент равен позиции в out => запускаем рекурсию без этого элемента
	int pos = it - (int)s.size(); // Элемент out, с которым производим сравнения
	//std::cout << s.size() << " " << it << " " << pos << std::endl;
	for (; it < n; ++it) {
		if (in[it] == out[pos]) {
			// Рекурсия без этой буквы (как будто мы её сразу вытолкнули)
			if (IsStackAnagram(in, out, it + 1, s)) {
				// Нам достаточно найти лишь один вариант
				return true;
			}
		}
		s.push(in[it]);
	}
	
	// Проверка, не скопилось ли на стеке нужное слово
	for (int i = n - (int)s.size(); i < n && s.top() == out[i]; ++i, s.pop()) {
		// std::cout << s.top() << " ";
	}
	// std::cout << std::endl;
	
	// Если удалось вытолкнуть всё - нужное слово получено
	return s.empty();
}

int main()
{
	// comment this line for reading from stdin
	freopen("test.txt", "r", stdin);
	
	// Вход - два слова
	std::string in, out;
	std::cin >> in >> out;
	
	// Вывод входных данных
	//std::cout << in << " " << out << std::endl;
	
	// Вычисляем, можно ли составить анаграмму из in в out на стеке
	if (IsStackAnagram(in, out, 0, std::stack<char>())) {
		std::cout << "YES";
	} else {
		std::cout << "NO";
	}

}